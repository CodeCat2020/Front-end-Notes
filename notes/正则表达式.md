



# 一、概述

正则表达式（regular expression）描述了一种字符串匹配的模式，可用于文本内容的查找和替换。

正则表达式内置于其它语言或者软件产品中，它本身不是一种语言或者软件。

正则表达式在线工具：

- [RegExr -- 正则表达式在线测试工具。](https://regexr.com/)
- [Regulex -- 正则表达式在线测试工具。](https://jex.im/regulex/#!flags=&re=^(a|b)*%3F%24)
- [正则表达式 在线工具 - 菜鸟教程](http://c.runoob.com/front-end/854)



为什么使用正则表达式？

通过使用正则表达式，可以：

- 测试字符串内的模式。
  例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。
- 替换文本。
  可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。
- 基于模式匹配从字符串中提取子字符串。
  可以查找文档内或输入域内特定的文本。



应用领域

- [C# 正则表达式](https://www.runoob.com/csharp/csharp-regular-expressions.html) 
- [Java 正则表达式](https://www.runoob.com/java/java-regular-expressions.html) 
- [JavaScript RegExp 对象](https://www.runoob.com/js/js-obj-regexp.html)
- [Python 正则表达式](https://www.runoob.com/python/python-reg-expressions.html)
- [Ruby 正则表达式](https://www.runoob.com/ruby/ruby-regular-expressions.html) 





# 二、语法

正则表达式包括普通字符和特殊字符（称为"元字符"）。

普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。



## 非打印字符

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| \cx  | 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| \f   | 匹配一个换页符。等价于 \x0c 和 \cL。                         |
| \n   | 匹配一个换行符。等价于 \x0a 和 \cJ。                         |
| \r   | 匹配一个回车符。等价于 \x0d 和 \cM。                         |
| \s   | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。 |
| \S   | 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。                  |
| \t   | 匹配一个制表符。等价于 \x09 和 \cI。                         |
| \v   | 匹配一个垂直制表符。等价于 \x0b 和 \cK。                     |



## 特殊字符

| 特别字符 | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| $        | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 `\$`。 |
| ( )      | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 `\(` 和 `\)`。 |
| *        | 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 `\*`。   |
| +        | 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 `\+`。   |
| .        | 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 `\.` 。  |
| [        | 标记一个中括号表达式的开始。要匹配 [，请使用 `\[`。          |
| ?        | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 `\?`。 |
| `\`      | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '`\\`' 匹配 "\"，而 '`\(`' 则匹配 "("。 |
| ^        | 匹配输入字符串的开始位置，除非在方括号表达式中使用。当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 `\^`。 |
| {        | 标记限定符表达式的开始。要匹配 {，请使用 `\{`。              |
| \|       | 指明两项之间的一个选择。要匹配 `\|`，请使用 `\|`。           |







# 三、运算符优先级

正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。

相同优先级的从左到右进行运算，不同优先级的运算先高后低。

下表从最高到最低说明了各种正则表达式运算符的优先级顺序：

| 运算符                      | 描述                                                         |
| :-------------------------- | :----------------------------------------------------------- |
| \                           | 转义符                                                       |
| (), (?:), (?=), []          | 圆括号和方括号                                               |
| *, +, ?, {n}, {n,}, {n,m}   | 限定符                                                       |
| ^, $, \任何元字符、任何字符 | 定位点和序列（即：位置和顺序）                               |
| \|                          | 替换，"或"操作 字符具有高于替换运算符的优先级，使得"m\|food"匹配"m"或"food"。若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m\|f)ood"。 |



# 四、预定义类

| 字符 | 等价类       |                 说明                 |
| :--: | ------------ | :----------------------------------: |
| `.`  | [^\r\n]      |     除了回车、换行之外的所有字符     |
|  \d  | [0-9]        |               数字字符               |
|  \D  | `[^0-9]`     |              非数字字符              |
|  \s  | [\f\n\r\t\v] |               空白字符               |
|  \S  |              |         对 \s 取非，非空白符         |
|  \w  | [a-zA-Z0-9_] | 单词字符（大小写字母，下划线和数字） |
|  \W  |              |        对 \w 取非，非单词字符        |



## 匹配单个字符 `.`

**.**   可以用来匹配任何的单个字符，但是在绝大多数实现里面，不能匹配换行符；

**.**   是元字符，表示它有特殊的含义，而不是字符本身的含义。如果需要匹配 . ，那么要用 \ 进行转义，即在 . 前面加上 \ 。

正则表达式一般是区分大小写的，但也有些实现不区分。

匹配一个“ab + 任意字符”的字符串：

```js
'abc-ab1c-a1b'.replace(/ab./g,'X'); 	// "X-Xc-a1b"
```



## 匹配特定的字符

\x 匹配十六进制字符，\0 匹配八进制，例如 \xA 对应值为 10 的 ASCII 字符 ，即 \n。



# 五、匹配一组字符 `[ ]`

**[ ]**   定义一个字符集合；

一般情况下正则表达式一个字符对应字符串一个字符，我们可以使用元字符 `[ ]` 来构建一个简单的类。所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符。

**字符类**

表达式 [abc] 把字符 a 或 b 或 c 归为一类，表达式可以匹配这类的字符。

```js
// 匹配 a 或 b 或 c
'a1b2c3AHND'.replace(/[abc]/g,'X');	 	// "X1X2X3AHND"
```

使用 **^**  创建反向类/负向类，即 **^**  在 [ ] 中是取非操作。

```js
// 匹配 a、b、c 以外的字符
'a1b2c3AHND'.replace(/[^abc]/g,'X'); 	// "aXbXcXXXXX"
```

**范围类**

0-9、a-z 定义了一个字符区间，区间使用 ASCII 码来确定，字符区间在 [ ] 中使用。

**-**   只有在 [ ] 之间才是元字符，在 [ ] 之外就是一个普通字符；

匹配数字：

```js
'2020-01-01'.replace(/[0-9]/g,'A');			// "AAAA-AA-AA"
```

匹配以 abc 为开头，并且最后一个字母不为数字的字符串：

```js
'abc1-abc2-abcd'.replace(/abc[^0-9]/g,'Q');			// "abc1-abc2-Q"
```

在 `[ ]` 组成的类内部是可以连写的。匹配小写英文字母和大写英文字母：

```js
'a1b2c3AHND'.replace(/[a-zA-Z]/g,'Q');			// "Q1Q2Q3QQQQ"
```

匹配数字和“-”：

```js
'2020-01-01'.replace(/[0-9-]/g,'A');		// "AAAAAAAAAA"
```







# 六、匹配空白字符

|  元字符 | 说明  |
| :---: | :---: |
|  [\b] | 回退（删除）一个字符   |
|  \f |  换页符 |
|  \n |  换行符 |
|  \r |  回车符 |
|  \t |  制表符 |
|  \v |  垂直制表符 |

\r\n 是 Windows 中的文本行结束标签，在 Unix/Linux 则是 \n。

\r\n\r\n 可以匹配 Windows 下的空白行，因为它匹配两个连续的行尾标签，而这正是两条记录之间的空白行；







# 七、重复匹配

限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。

有 6 种限定符：

| 字符  | 等价  | 描述                                                         |
| :---- | ----- | :----------------------------------------------------------- |
| *     | {0,}  | 匹配前面的子表达式 0 次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。 |
| +     | {1,}  | 匹配前面的子表达式 1 次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。 |
| ?     | {0,1} | 匹配前面的子表达式 **0 次或 1 次**</u>。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。 |
| {n}   |       | 出现 n 次（n 是一个非负整数）。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |
| {n,}  |       | 至少出现 n 次（n 是一个非负整数）。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 |
| {n,m} |       | 最少出现 n 次且最多出现 m 次（m 和 n 均为非负整数，其中 n <= m）。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |

**贪婪模式**

```js
('12345678'.replace)(/\d{3,6}/,'X');		// "X78"
```

`*` 和 `+` 都是贪婪型元字符，会匹配尽可能多的内容。

```js
('abcabcabc'.replace)(/a.+c/,'X');		// "X"
```

**非贪婪模式**

尽可能少的匹配，也就是说，一旦匹配成功就不再继续尝试。

在后面加 ? 可以转换为懒惰型元字符，例如 \*?、+? 和 {m,n}? 。

```js
('12345678'.replace)(/\d{3,6}?/,'X');		// "X45678"
```



匹配邮箱地址。

```
[\w.]+@\w+\.\w+
```

[\w.] 匹配的是字母数字或者 . ，在其后面加上 + ，表示匹配多次。在字符集合 [ ] 里，. 不是元字符；

**匹配结果**  

**abc.def<span>@</span>qq.com**  





# 八、位置匹配

定位符用来描述字符串或单词的边界

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| ^    | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 |
| $    | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 |
| \b   | 单词边界，即字与空格间的位置。                               |
| \B   | 非单词边界。                                                 |

**注意**：不能将限定符（重复匹配）与定位符（位置匹配）一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 **^\*** 之类的表达式。



## 单词边界

**\b**   可以匹配一个单词的边界，边界是指位于 \w 和 \W 之间的位置；**\B** 匹配一个不是单词边界的位置。

\b 只匹配位置，不匹配字符，因此 \babc\b 匹配出来的结果为 3 个字符。

```js
('This is a boy').replace(/is/g,'X');		// "ThX X a boy"
('This is a boy').replace(/\bis\b/g,'X');	// "This X a boy"
('This is a boy').replace(/\Bis\b/g,'X');	// "ThX is a boy"
```



## 字符串边界

**^**   匹配整个字符串的开头，**$** 匹配结尾。

^ 元字符在字符集合中用作求非，在字符集合外用作匹配字符串的开头。

分行匹配模式（multiline）下，换行被当做字符串的边界。

**应用**  

匹配代码中以 // 开始的注释行

**正则表达式**  

```
^\s*\/\/.*$
```

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/600e9c75-5033-4dad-ae2b-930957db638e.png"/> </div><br>

**匹配结果**  

1. public void fun() {
2. &nbsp;&nbsp;&nbsp;&nbsp;      **// 注释 1**  
3. &nbsp;&nbsp;&nbsp;&nbsp;    int a = 1;
4. &nbsp;&nbsp;&nbsp;&nbsp;    int b = 2;
5. &nbsp;&nbsp;&nbsp;&nbsp;      **// 注释 2**  
6. &nbsp;&nbsp;&nbsp;&nbsp;    int c = a + b;
7. }

# 九、子表达式 `( )`

**分组**

使用   **( )**   定义一个子表达式。子表达式的内容可以当成一个独立元素，即可以将它看成一个字符，并且使用 * 等元字符。

```js
'a1b1c3d4'.replace(/[a-z]\d{3}/g,'X');			// "a1b1c3d4"
'a1b1c3d4'.replace(/([a-z]\d){3}/g,'X');		// "Xd4"
```

子表达式可以嵌套，但是嵌套层次过深会变得很难理解。



**或**

 **|** 是或元字符，它把左边和右边所有的部分都看成单独的两个部分，两个部分只要有一个匹配就行。

```js
'1900-2010-1020'.replace(/(19|20)\d{2}/g,'X');			// "X-X-1020"
```



**应用**  

匹配 IP 地址。

IP 地址中每部分都是 0-255 的数字，用正则表达式匹配时以下情况是合法的：

- 一位数字
- 不以 0 开头的两位数字
- 1 开头的三位数
- 2 开头，第 2 位是 0-4 的三位数
- 25 开头，第 3 位是 0-5 的三位数

**正则表达式**  

```
((25[0-5]|(2[0-4]\d)|(1\d{2})|([1-9]\d)|(\d))\.){3}(25[0-5]|(2[0-4]\d)|(1\d{2})|([1-9]\d)|(\d))
```

**匹配结果**  

1.   **192.168.0.1**  
2. 00.00.00.00
3. 555.555.555.555



## 回溯引用

回溯引用使用   **\n**   来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和子表达式匹配的内容一致，比如子表达式匹配到 abc，那么回溯引用部分也需要匹配 abc 。

匹配 HTML 中合法的标题元素。

\1 将回溯引用子表达式 (h[1-6]) 匹配的内容，也就是说必须和子表达式匹配的内容一致。

```js
'<h1>x</h1><h2>y</h2><h3>z</h1>'.replace(/<(h[1-6])>\w*?<\/\1>/g,'X');
// "XX<h3>z</h1>"，/n 表示回溯引用
'<h1>x</h1><h2>y</h2><h3>z</h1>'.replace(/<(h[1-6])>\w*?<\$1>/g,'X');
// "<h1>x</h1><h2>y</h2><h3>z</h1>"，$ 用在替换中
```





## 替换

需要用到两个正则表达式：查找正则表达式和替换正则表达式。

替换正则表达式使用 $ 来引用某个子表达式（从 1 开始计算）。

**应用**  

修改日期格式。

```js
'2020-01-01'.replace(/(\d{4})-(\d{2})-(\d{2})/g,'$2/$3/$1');
// "01/01/2020"
```

修改电话号码格式。

```js
'313-555-1234'.replace(/(\d{3})(-)(\d{3})(-)(\d{4})/g,'($1) $3-$5');
// "(313) 555-1234"
```



## 忽略分组

不希望捕获某些分组，在分组内加上 `? :` 即可。

```js
'2020-01-31'.replace(/(\d{4})-(\d{2})-(\d{2})/g,'$1');		// "2020"
'2020-01-31'.replace(/(?:\d{4})-(\d{2})-(\d{2})/g,'$1');	// "01"
```





## 大小写转换

|  元字符 | 说明  |
| :---: | :---: |
|  \l | 把下个字符转换为小写  |
|   \u| 把下个字符转换为大写  |
|  \L | 把\L 和\E 之间的字符全部转换为小写  |
|  \U | 把\U 和\E 之间的字符全部转换为大写  |
|  \E | 结束\L 或者\U  |

**应用**  

把文本的第二个和第三个字符转换为大写。

**文本**  

abcd

**查找**  

```
(\w)(\w{2})(\w)
```

**替换**  

```
$1\U$2\E$3
```

**结果**  

aBCd

# 十、前瞻后顾

正则表达式从文本头部向尾部开始解析，文本尾部方向，称为“前”。

前后查找（前瞻后顾）规定了匹配的内容首尾应该匹配的内容，但是又不包含首尾匹配的内容。

前瞻就是在正则表达式匹配到规则的时候，向前检查是否符合断言（一个正则表达式），后顾/后瞻方向相反。（注： JavaScript 不支持向后匹配，Java 对其支持也不完善）

符合和不符合特定断言称为：肯定/正向匹配和否定/负向匹配。

| 名称     | 正则           | 含义                                            |
| -------- | -------------- | ----------------------------------------------- |
| 正向前瞻 | exp(?=assert)  | 替换时不包括小括号里面的内容。                  |
| 负向前瞻 | exp(?!assert)  | 替换时不包括小括号里面的内容。                  |
| 正向后顾 | exp(?<=assert) | 替换时不包括小括号里面的内容。JavaScript 不支持 |
| 负向后顾 | exp(?<!assert) | 替换时不包括小括号里面的内容。JavaScript 不支持 |

**应用**  

匹配单词字符后面是数字的单词字符：

```js
'a2*34v8'.replace(/\w(?=\d)/g,'X');		// "X2*X4X8"
```

匹配单词字符前面是数字的字符串：（？）

```js
'a2*34v8'.replace(/\w(?<=\d)/g,'X');		// "aX*XXvX"
```

查找出邮件地址 @ 字符前面的部分。

```js
'abc@qq.com'.replace(/\w+(?=@)/g,'X');		// "X@qq.com"
```







# 十一、嵌入条件

## 回溯引用条件

条件为某个子表达式是否匹配，如果匹配则需要继续匹配条件表达式后面的内容。

**正则表达式**  

子表达式 (\\() 匹配一个左括号，其后的 ? 表示匹配 0 个或者 1 个。 ?(1) 为条件，当子表达式 1 匹配时条件成立，需要执行 \) 匹配，也就是匹配右括号。

```
(\()?abc(?(1)\))
```

**结果**  

1.   **(abc)**  
2.   **abc**  
3. (abc

## 前后查找条件 `?(?=-)`

条件为定义的首尾是否匹配，如果匹配，则继续执行后面的匹配。注意，首尾不包含在匹配的内容中。

**正则表达式**  

 ?(?=-) 为前向查找条件，只有在以 - 为前向查找的结尾能匹配 \d{5} ，才继续匹配 -\d{4} 。

```
\d{5}(?(?=-)-\d{4})
```

**结果**  

1.   **11111**  
2. 22222-
3.   **33333-4444**  





# 参考资料

- BenForta. 正则表达式必知必会 [M]. 人民邮电出版社, 2007.
- [JavaScript 正则表达式 - 慕课网课程（2020.07.27-2020.07.28）](https://www.imooc.com/learn/706)
- [正则表达式 - 菜鸟教程](https://www.runoob.com/regexp/regexp-tutorial.html)





