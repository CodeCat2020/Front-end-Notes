

# 概述

编译的 5 个阶段：词法分析、语法分析、语义分析与中间代码生成、优化、目标代码生成



翻译程序：能够把某种语言转换成另一种语言的程序，而两者在逻辑上是等价的

解释程序：以源程序为输入，不产生目标程序，而是边解释边执行源程序本身的程序。

诊断编译程序：帮助程序开发和调试的程序。

优化编译程序：提高目标代码效率的程序。

运行编译程序的是宿主机，运行目标代码的是目标机。

交叉编译：编译程序产生不同于宿主机的目标代码。

可变编译程序：不需要重写编译程序中与机器无关的部分就能改变目标机。

程序语言由语法和语义两方面定义。

语句包括：说明性语句、执行性语句

子程序传参方式：传值、传地址、传名

空间分配分方式：静态存储分配、动态存储分配

表格管理:对各种表格进行管理,包括表格的构造、查找、修改、删除、插入等；

# 编译原理基础

## 词法分析

词法分析：把源程序作为字符串进行扫描 ，根据单词词法，识别出所有单词，过滤无用符，并检查是否为合法的单词。

词法分析的工具：正规式、有限自动机。

单词一般分为如下几种：基本字，标识符，常数，算符，界符。

词法规则：规定了形成单词的规则；如常数，标识符，基本字，算符等。

识别单词符号的方法：超前搜索

源程序的预处理：过滤无关的符号。

状态图由三种结构构成：分支结构、循环结构、终结点

LEX语言源程序由两部分组成：正规式辅助定义式、识别规则





## 语法分析

语法分析: 根据语言的语法规则,从单词符号串中识别出各种语法单位 ,进行句子分析,并检查整个输入字串是否为合法的程序。

语法=词法规则+语法规则

语法规则：规定了由单词构造更大语法单位的规则；如表达式，短语，语句，程序等。

语法分析方法：自上而下（算符优先）、自下而上（递归下降）

重要的语法单位：程序,子程序,语句,短语,表达式等

上下文无关文法组成：终结符号、非终结符号、开始符号、产生式

句柄.：一个句型的最左直接短语。

素短语：至少含有一个终结符,且不可在分割成为更小的短语。一个句型的最左素短语即为可归约串。

递归下降分析的两个问题:文法的左递归、文法的回溯。

语法制导翻译：在语法分析的每次归约或推导时,根据产生式的语义进行翻译的一种方法。

## 符号表

编译程序中最主要的有如下几种：符号表，常量表，标号表，子程序名表，四元式表等。
符号表的查找技术：线性查找、二叉查找树、哈希表

符号表的基本操作：查找、插入、访问、修改、删除

## 中间代码生成

中间代码生成：根据语义规则,把各种语法单位翻译成中间代码序列.

静态语义检查：类型检查、控制流检查、一致性检查、相关名字检查

中间代码的表示方法：四元式、三元式、间接三元式、逆波兰式、树形表示、DAG
优化



代码优化：对产生的中间代码序列进行加工变换，使变换后的代码更为高效。

优化的几种方法：删除公共子表达式、复写传播、删除无用代码、代码外提、强度削弱、删除归纳变量。

必经节点集：流图通路中所必须经过的节点的集合

回边：必经节点集中从后方节点到前方节点的边



可规约流图：流图中除去回边而剩余部分构成无环路的流图.



引用定值集ud[A]：能到达引用点u-A（u点引用了A）的变量A的所有定值点[d1,d2…dn]的集合（A在d定值）。



## 目标代码生成

目标代码生成：把中间代码程序翻译为机器指令或汇编指令程序。

生成的目标代码形式：绝对机器代码、可重定位机器代码、汇编语言代码



# C 语言的编译过程

> https://juejin.im/post/594e77ef5188250d9e6504bc

整个流程包括**预处理**、**词法分析**、**语法分析**、**生成中间代码**，**生成目标代码**，**汇编**，**链接** 等

对于 C 语言来说，从源码到运行结果大致上需要经历三个步骤。

- 编译：编译器（负责前五个步骤）接收源代码，输出目标代码(也就是汇编代码)。
- 汇编：汇编器接收汇编代码，输出由机器码组成的目标文件(二进制格式，.o 后缀)。
- 链接：最后链接器将各个目标文件链接起来，执行重定位，最终生成可执行文件。

编译器以中间代码为界限，又可以分前端和后端。比如 clang 就是一个前端工具，而 LLVM 则负责后端处理。工具 GCC(GNU Compile Collection) 则是一个套装，包揽了前后端的所有任务。前端主要负责预处理、词法分析、语法分析，最终生成语言无关的中间代码。后端主要负责目标代码的生成和优化。



## 编译



### 预处理

### 词法分析

- 主要难点：前缀无法决定一个完整字符串的含义，通常需要看完整句以后才知道每个单词的具体含义。
- 实现原理：状态机。逐个读取字符，然后根据读到的字符的特点转换状态。
- 实现：外循环 + `switch...case` 。

### 语法分析

经过词法分析后，编译器知道了每个单词，但这些单词组合起来表示的语法还不清楚。一个简单的思路是模板匹配：

```
int a = 10;
```

对应一种通用的语法格式：

```
类型 变量名 = 常量;
```

语法分析比词法分析更复杂，因为所有 C 语言支持的语法特性都必须被语法分析器正确的匹配。不过这个属于业务复杂性，无论采用哪种解决方案都不可避免，因为语法规则的数量就是这么多。



### 生成中间代码

以 GCC 为例，生成中间代码可以分为三个步骤:

1. 语法树转高端 gimple
2. 高端 gimple 转低端 gimple
3. 低端 gimple 经过 cfa 转 ssa 再转中间代码

### 生成目标代码







## 汇编





## 链接



# 自举

C 语言的编译器是还是用 C 语言实现的。这种自己能编译自己的能力被称为自举(Bootstrap)。

原理：不断用低级语言来写高级语言的编译器

C 语言自举原理：

先用一个比 C 语言低级但比汇编高级的语言（假定为 X 语言）来实现 C 语言的编译器（假定为编译器 Compile1），同时用汇编来实现 X 语言的编译器。

写好的  C 语言编译器 Compile1 是二进制格式的，此时可以删掉所有低级语言。接下来用 C 语言写编译器 Compile2，再用这个二进制格式的编译器 Compile1 去编译 C 语言实现的 C 语言编译器Compile1 ，于是完成了自举。

简单的说，C 语言可以自举是因为它可以编译成二进制机器码

一门语言能不能自举，主要取决于它的实现形式能否被编译并留下二进制格式的可执行文件。



# 总结

机器语言：计算机执行的二进制命令，都是 0 和 1表示的

汇编语言：用助记符代替机器指令的操作码（如：ADD 表示加法）

高级语言：更简单，符合人们的习惯，也更容易理解和修改。高级语言经过编译器编译之后可以得到目标程序。（如：C++、Java）

**机器语言、汇编语言、高级语言的区别**：

依次接近人类自然语言的表达方式、代码效率依次变低、语言越来越高级。

越低级的语言越简单，但表达能力越弱。

**机器语言、汇编语言、高级语言的联系**：

高级语言要通过编译程序翻译成汇编代码，汇编语言要通过汇编得到机器语言，计算机才能执行。

**汇编语言和高级语言的区别**：

- 可移植性

  - 汇编语言无可移植性。

    每一款 CPU 都有自己的指令集，即使是有相同的指令集的不同芯片，汇编的语法也可能会有所不同。汇编语言都是针对某一种芯片编写的，对硬件的依赖程度很高。

  - C 语言有一定可移植性，Java 等更高级语言移植性更强。

    用 C 语言编写的代码，可用于不同的 CPU上。每一款 CPU 都有其特定的 C 语言编译器。

- 执行效率：汇编语言效率最高，C 语言次之，Java 等更高级语言效率更低。

- 编写难度：汇编语言难写，不适合完成大型复杂的项目。高级语言更适合完成更大、更复杂的项目。







# 参考资料