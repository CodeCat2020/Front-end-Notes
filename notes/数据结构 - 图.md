



# 一、概述

## 定义 & 术语

1、定义

图（Graph）的定义：图 G 是由两个集合 V(G) 和 E(G) 组成的，记为 G=(V,E)。其中：V(G) 是顶点的非空有限集；E(G) 是边的有限集合，边是顶点的无序对或有序对。

- 顶点（Vertex）：图中的数据元素。线性表中的数据元素叫元素，树中的数据元素叫结点。

- 在图结构中，不允许没有顶点，顶点集合 V 有穷非空。线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。

- 在图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。

  线性表中， 相邻的数据元素之间具有线性关系。树结构中，相邻两层的结点具有层次关系。



2、术语

- 
  各种图的定义
  - 无向边：若项点 V<sub>i</sub> 到 V<sub>j</sub> 之间的边没有方向，则称这条边为无向边(Edge)， 用无
    序偶对 (V<sub>i</sub>，V<sub>j</sub>) 来表示。如果图中任意两个顶点之间的边都是无向边，则称该图为无向图(Undirected graphs)。 
  - 无向图：无向图 G 是由两个集合 V(G) 和 E(G) 组成的。其中：V(G) 是顶点的非空有限集。E(G) 是边的有限集合，边是顶点的无序对，记为（v,w）或（w,v），并且（v,w)=(w,v)（顶点对是无序的）
  - 有向边：若从顶点 V<sub>i</sub> 到 V<sub>j</sub> 的边有方向，则称这条边为有向边，也称为弧（Arc ）。
  - 有向图：有向图 G 是由两个集合 V(G) 和 E(G) 组成的。其中：V(G) 是顶点的非空有限集。E(G) 是有向边（也称弧）的有限集合，弧是顶点的有序对，记为 <v,w>，v，w 是顶点，v 为弧尾（Tail），w 为弧头（Head）(顶点对是有序的）
  - 简单图：图中不存在顶点到其自身的边，且同一条边不重复出现。
  - 无向完全图：任意两个顶点之间都存在边。含有 n 个顶点的无向完全图有 n(n-1)/2 条边。
  - 有向完全图：任意两个顶点之间都存在方向互为相反的两条弧。含有 n 个顶点的有向完全图有 n(n-1) 条弧。
  - 稀疏图与稠密图：若边或弧的个数小于 nlogn，则称作稀疏图，否则称稠密图。
  - 权（Weight）：把图的边或弧赋予一个有意义的数，此数叫权。
  - 网（Network）：弧或边带权的图分别称作有向网或无向网。
  - 子图（subgraph）：如果图 G(V,E) 和图 G’(V’,E’) 满足：V’⊆V 且 E’⊆E，则称 G’ 为 G 的子图。

- 顶点和边之间的关系
  - 邻接点（Adjacent）：如果 (u, v) 是 E(G) 中的一条边，则称 u 与 v 互为邻接的顶点。

  - 顶点的度：

    在无向图中，顶点的度是与该顶点相连的边数。在有向图中，顶点的度分成入度和出度

    - 入度：以该顶点为弧头的弧的数目
    - 出度：以该顶点为弧尾的弧的数目

  - 路径：在图 G＝(V, E) 中, 若从顶点 v<sub>i</sub> 出发, 沿一些边经过一些顶点 v<sub>p1</sub>, v<sub>p2</sub>, …, v<sub>pm</sub>，到达顶点 v<sub>j</sub> 。则称顶点序列 ( v<sub>i</sub>  v<sub>p1</sub>  v<sub>p2</sub> ...  v<sub>pm</sub> v<sub>j</sub> ) 为从顶点 v<sub>i</sub> 到顶点 v<sub>j</sub> 的路径。它经过的边 (v<sub>i</sub>, v<sub>p1</sub>)、(v<sub>p1</sub>, v<sub>p2</sub>)、...、(v<sub>pm</sub>, v<sub>j</sub>)要求是属于 E 的边。

  - 路径长度：非带权图的路径长度是指此路径上边的条数；带权图的路径长度是指路径上各边的权之和。

  - 简单路径：路径上各顶点 v1,v2,...,vm 均不重复。

  - 回路：若路径上第一个顶点 v1 与最后一个顶点vm 重复，则称这样的路径为回路或环。

- 连通图相关

  - 连通图：在无向图中，若从顶点 vi 到顶点 vj 有路径, 则称顶点 vi 与 vj 是连通的。如果图中任意一对顶点都是连通的，则称此图是连通图。
  - 连通分量：非连通图的极大连通子图叫做连通分量。
  - 强连通图：在有向图中, 若对于每一对顶点 vi 和 vj，都存在一条从 vi 到 vj 的路径和从一条 vj 到 vi 的路径, 则称此图是强连通图。
  - 强连通分量：非强连通图的极大强连通子图叫做强连通分量。
  - 生成树：一个连通图的生成树是其极小连通子图，在 n 个顶点的情形下，有 n-1 条边。对非连通图，则称由各个连通分量的生成树的集合为该非连通图的生成森林。



## 抽象数据类型

基本操作

1)    CreateGraph(&G, V, VR)://按定义(V, VR)构造图

2)    DestrovGraph(&G)://销毁图

3)    LocateVex(G, u);"若G中存在顶点u，则返回该顶点在图中的“位置”;否则返回其它信息。

4)    GetVex(G, v);//返回v的值。

5)    PutVes(&G, v, value);//对v赋值value。

6)    FirstAdjVex(G, v); ;//返回v的“第-一个邻接点”。若该顶点

7)    //在G中没有邻接点，则返回“空。

8)    NextAdjVex(G, v, w);//返回v的(相对于w的)“下一个邻接点” 。若w是v的最后一个邻接点，则返回“空”

9)    InsertVex(&G, v); .//在图G中增加新顶点v。.

10)  DeleteVex(&G, V);//删除G中顶点v及其相关的弧。

11)  InsertArc(&G, v, w);//在G中增加弧<v,w>，若G是无向的，.//则还增加对称弧(w, v)。

12)  DeleteArc(&G, V, w);//在G中删除弧<v, w>,若G是无向的，//则还删除对称弧(w, v)。

13)  图的遍历-- (用的最多，最重要)

14)  DFSTraverse(G, v, VisitO);//从顶点v起深度优先遍历图G，并对每个顶点调用函数Visit一次且仅一次。

15)  BFSTraverse(G, v, VisitO);//从顶点v起广度优先遍历图G，并对每个顶点调用函数Visit一次且仅一次。



# 二、图的存储结构

图的数组存储表示（邻接矩阵）

图的邻接表存储表示（）

有向图的十字链表存储表示

无向图的邻接多重表存储表示





## 邻接矩阵

图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。



## 邻接表



## 十字链表







## 邻接多重表



## 边集数组







# 三、图的遍历

图的遍历：从图中某个顶点出发游历图，访遍图中其余顶点，并且使图中的每个顶点仅被访问一次的过程。



### DFS

深度优先遍历（Depth First Search，DFS），也称为深度优先搜索。

- 适用：不允许有环
- 算法步骤：
- - 从图中某个顶点V0 出发，访问此顶点;

  - 依次从V0的各个未被访问的邻接点出发深度优先搜索遍历图，

  - 直至图中所有和V0有路径相通的顶点都被访问到。

- 代码实现

```C
void DFS(Graph G, int v) {
   // 从顶点v出发，深度优先搜索遍历连通图 G
    visited[v] = TRUE;
    VisitFunc(v);
    for(w=FirstAdjVex(G, v);
        w!=0;
        w=NextAdjVex(G,v,w))
        if (!visited[w])
            DFS(G, w); // 对v的尚未访问的邻接顶点w，递归调用DFS
} // DFS
```

 



### BFS

广度优先遍历（Breadth First Search，BFS），又称广度优先搜索。

类似于树的按层次遍历的过程。广度优先搜索遍历图的过程是以 v 为起始点，由近至远，依次访问和 v 有路径相通且路径长度为1，2，……的顶点。





1)    算法步骤

- 从图中的某个顶点 V<sub>0</sub> 出发，并访问此顶点；

- 依次访问 V<sub>0</sub> 的所有未被访问过的邻接点;

- 按这些顶点被访问的先后次序依次访问它们的邻接点，直至图中所有和 V<sub>0</sub> 有路径相通的顶点都被访问到。

- 若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。






# 四、最小生成树

问题

假设要在 n 个城市之间建立通讯联络网，则连通 n 个城市只需要修建 n-1条线路，如何在最节省经费的前提下建立这个通讯网？构造网的一棵最小生成树，即：在 e 条带权的边中选取 n-1 条边（不构成回路），使“权值之和”为最小。

如果权值最小的 n-1 条边构成了环的话，就不能构成最小生成树



算法策略选择

- 普里姆算法（Prim）：在保证连通的前提下依次选出权重较小的 n-1 条边（在实现中体现为 n 个顶点的选择）。
- 克鲁斯卡尔算法（Kruskal）：在保证无回路的前提下依次选择权重较小的  条边。(在实现中体现为 n-1 个边的选择)



### Prim



### Kruskal



 

# 五、重（双）连通图和关节点

# 六、最短路径

应用

求从某个源点到其余各点的最短路径

每一对顶点之间的最短路径



### Dijkstra算法

求从源点到其余各点的最短路径的算法的基本思想: 依最短路径的长度递增的次序求得各条路径。其中，从源点到顶点v的最短路径是所有最短路径中长度最短者。

 

 

 

 

# 七、 拓扑排序



Topological sorting



\1.    简介

对一个有向无环图（Directed Acyclic Graph，简称DAG）G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u，v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。

在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序

- 每个顶点出现且只出现一次；

- 若A在序列中排在B的前面，则在图中不存在从B到A的路径。


注意:1)只有有向无环图才存在拓扑序列;2)对于一个DAG，可能存在多个拓扑序列;



\2.    算法步骤

1)    在有向图中选一个没有前驱（入度为0）的顶点并输出。

2)    从图中删除该顶点及它发出的弧（这样就得到了别的入度为0的顶点）。

3)    重复上述两步，直至图空，或者图不空但找不到无前驱的顶点为止。然后输出全部顶点。



\3.    代码思路

从描述上可以看出，我们需要记录每个顶点的入度，实现如下：由于没有记录入度这一信息，先要求出一个入度数组，来表示每个顶点的入度，这个入度数组还要动态更新，当一个顶点被删除后，它指向的顶点的入度都要减1.



\4.    复杂度分析

时间复杂度： O(n + e)，其中n为图中的结点数目，e为图中的边的数目

空间复杂度：O(n)

也可以用深度优先遍历DFS和 广度优先遍历BFS 实现拓扑排序。

 

 

# 八、 关键路径

 


